# -*- coding: utf-8 -*-
"""vectors.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FxOwo5wu7ODcnmrI-e7KZj5s5U6szewC
"""

ISIZE = 5000
JSIZE = 5000

"""Для первого цикла $a[i][j] = \sin(0.1*a[i+4][j+2]);$"""

def f1(i):
    return i

def f2(j):
    return j

def g1(i):
    return i + 4

def g2(j):
    return j + 2

fist_solution_set = []
second_solution_set = []

for mu in range(ISIZE - 4):
    for lambd in range(2, JSIZE):
        if (f1(mu) == g1(lambd)):
            fist_solution_set.append((mu, lambd))

for mu in range(ISIZE - 2):
    for lambd in range(2, JSIZE):
        if (f2(mu) == g2(lambd)):
            second_solution_set.append((mu, lambd))

"""Исследуем получившиеся множества решений"""

fist_solution_set[:2]

second_solution_set[:2]

"""$D_1 = (>, >)$

Пусть многомерный цикл имеет вектор направлений d, в состав
которого входят только элементы «>» и «=». Такой цикл может быть
распараллелен без всяких ограничений по любому количеству
индексов, соответствующих компонентам «=» в векторе направлений.
Распараллеливание по индексам, соответствующим компонентам «>»
в векторе направлений, возможно при дублировании необходимых
входных
данных.
Перед
распараллеливанием
циклы,
соответствующие различным уровням вложенности первоначальной
конструкции, можно безопасно менять местами.


"Достаточно запомнить "полоски" на границах на глубину антизависимости и спокойно распараллелить по внешнему циклу"
Это был пункт 2е, переходим к пункту 1е.
"""

def f1(i):
    return i

def f2(j):
    return j

def g1(i):
    return i - 1

def g2(j):
    return j - 8

fist_solution_set = []
second_solution_set = []

for mu in range(1, ISIZE):
    for lambd in range(8, JSIZE):
        if (f1(mu) == g1(lambd)):
            fist_solution_set.append((mu, lambd))

for mu in range(1, ISIZE):
    for lambd in range(8, JSIZE):
        if (f2(mu) == g2(lambd)):
            second_solution_set.append((mu, lambd))

fist_solution_set[:2]

second_solution_set[:2]

"""$D_2 = (<, <)$

Пусть многомерный цикл имеет вектор направлений d, в состав
которого входят только элементы „<“ и „=“. Такой цикл может быть
распараллелен без всяких ограничений по любому количеству
индексов, соответствующих компонентам „=“ в векторе направлений.
Распараллеливание по индексам, соответствующим компонентам „<“
в векторе направлений, проблематично. Перед распараллеливанием
циклы, соответствующие различным уровням вложенности
первоначальной конструкции, можно безопасно менять местами.
Пусть для некоторого многомерного цикла определен вектор
направлений d. Истинная зависимость в цикле существует тогда и
только тогда, когда крайний левый элемент вектора направлений,
отличный от „=“, есть „<“.

"сложнее. если ограничить число исполнителей числом 8, вспомнить, что циклы можно 
менять местами и распараллелить по внешнему циклу до 8 исполнителей (т.е один делает
8,16, другой 9,17,..., потом 10,18 и тд), то можно решить просто

Это был пункт 1е. Переходим к 3е.
"""

'''
for (int i = 0; i < ISIZE; ++i){
    for (int j = 0; i < JSIZE; ++j) {
        a[i][j] = sin(0.002*a[i][j]);
        if (j >= 1 and i < ISIZE-4) {
            b[i][j] = a[i+4][j-1] * 1.5
        }
    }
}
'''

"""То есть при условиях $j >= 1$ and $i < ISIZE-4$ возможно нарушение условий Бернстрайна"""

def f1(i):
    return i

def f2(j):
    return j

def g1(i):
    return i + 4

def g2(j):
    return j - 1

fist_solution_set = []
second_solution_set = []

for mu in range(ISIZE - 4):
    for lambd in range(1, JSIZE):
        if (f1(mu) == g1(lambd)):
            fist_solution_set.append((mu, lambd))

for mu in range(ISIZE - 4):
    for lambd in range(1, JSIZE):
        if (f2(mu) == g2(lambd)):
            second_solution_set.append((mu, lambd))

fist_solution_set[:2]

second_solution_set[:2]

"""$D_2 = (>, <)$

Антизависимость. Значения массива сначала используются, а потом вычисляются. 
Можно распараллелисть по внутреннему циклу с копированием данных.

можно не объединять циклы. тогда надо после первого цикла (который легко
параллелится) не забыть поставить барьерную синхронизацию, второй тоже легко распараллеливается
"""